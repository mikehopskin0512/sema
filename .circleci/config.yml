version: 2.1
orbs:
  slack: circleci/slack@4.4
  openvpn: titel-media/openvpn@0.1.1
  browser-tools: circleci/browser-tools@1.2.4
jobs:
  deploy-web:
    environment:
      AWS_REGION: us-east-1
    docker:
      - image: cimg/base:2020.01
    steps:
      - checkout
      - run:
          name: install utilities
          command: sudo apt-get update -y && sudo apt-get install awscli -y && sudo apt-get install jq -y
      - setup_remote_docker:
          version: 18.09.3
      - run:
          name: create phoenix profile for aws cli
          command: printf "%s\n%s\n"${AWS_REGION}"\njson" "$AWS_ACCESS_KEY_ID" "$AWS_SECRET_ACCESS_KEY" | aws configure --profile phoenix
      - run:
          name: set deployment environment
          command: |
            if [ $CIRCLE_BRANCH = "master" ]; then
              echo 'export ENV=prod' >> $BASH_ENV
            elif [ $CIRCLE_BRANCH = "qa" ]; then
              echo 'export ENV=qa' >> $BASH_ENV
            elif [[ "$CIRCLE_BRANCH" == "release"* ]]; then
              echo 'export ENV=staging' >> $BASH_ENV
            fi
      - run:
          name: build and deploy phoenix/web
          command: cd web && ./build-and-deploy.sh $ENV
      - slack/notify:
          event: fail
          template: basic_fail_1
          channel: "phoenix-circleci-notifications"
  test-web:
    environment:
      AWS_REGION: us-east-1
    machine:
      image: ubuntu-2004:202111-02
    steps:
      - checkout
      - openvpn/install
      - browser-tools/install-chrome
      - browser-tools/install-chromedriver
      - run:
          name: Init VPN
          command: |
            echo "${VPN_CONFIG}" | base64 --decode >> config.ovpn
            echo "${VPN_LOGIN}" | base64 --decode >> vpn.login
      - run:
          name: Connect to VPN
          command: |
            sudo openvpn --config config.ovpn --askpass vpn.login > openvpn.log 2>&1 &
            while [ -n "$(ip addr show tun0 2>&1 > /dev/null)" ]; do
              sleep 0.1;
            done
            cat openvpn.log
      - run:
          name: install utilities
          command: sudo apt-get update -y && sudo apt-get install awscli -y
      - run:
          name: create phoenix profile for aws cli
          command: printf "%s\n%s\n"${AWS_REGION}"\njson" "$AWS_ACCESS_KEY_ID" "$AWS_SECRET_ACCESS_KEY" | aws configure --profile phoenix
      - run:
          name: set deployment environment
          command: |
            if [ $CIRCLE_BRANCH = "master" ]; then
              echo 'export ENV=prod' >> $BASH_ENV
            elif [ $CIRCLE_BRANCH = "qa" ]; then
              echo 'export ENV=qa' >> $BASH_ENV
            elif [[ "$CIRCLE_BRANCH" == "release"* ]]; then
              echo 'export ENV=staging' >> $BASH_ENV
            elif [[ "$CIRCLE_BRANCH" == "DVPS-125" ]]; then
              echo 'export ENV=staging' >> $BASH_ENV
            fi
      - run: 
          name: waiting until web and apollo get stable
          command: |
            aws ecs wait services-stable --profile phoenix --cluster "${ENV}-frontend" \
                --services apollo phoenix
      - run: 
          name: test python script
          command: |
            import requests
            import re
            import sys 
            import json
            import time
            import os

            # secs for polling Jenkins API
            #
            QUEUE_POLL_INTERVAL = 2 
            JOB_POLL_INTERVAL = 20
            OVERALL_TIMEOUT = 3600 # 1 hour

            # job specifics: should be passed in
            
            auth_token = os.getenv('JENKINS_AUTH_TOKEN')
            jenkins_uri = os.getenv('JENKINS_URI')
            job_name = os.getenv('JENKINS_JOB_NAME')
            build_token = os.getenv('JENKINS_BUILD_TOKEN')

            # start the build
            #
            start_build_url = 'http://{}@{}/job/{}/build?token={}'.format(
                    auth_token, jenkins_uri, job_name, build_token)
            r = requests.post(start_build_url)

            # from return headers get job queue location
            #
            m = re.match(r"http.+(queue.+)\/", r.headers['Location'])
            if not m:
              # To Do: handle error
              print("Job starte request did not have queue location")
              sys.exit(1)

            # poll the queue looking for job to start
            #
            queue_id = m.group(1)
            job_info_url = 'http://{}@{}/{}/api/json'.format(auth_token, jenkins_uri, queue_id)
            elasped_time = 0 
            print('{} Job {} added to queue'.format(time.ctime(), job_name))
            while True:
              l = requests.get(job_info_url)
              jqe = l.json()
              task = jqe['task']['name']
              try:
                  job_id = jqe['executable']['number']
                  break
              except:
                  #print "no job ID yet for build: {}".format(task)
                  time.sleep(QUEUE_POLL_INTERVAL)
                  elasped_time += QUEUE_POLL_INTERVAL

              if (elasped_time % (QUEUE_POLL_INTERVAL * 10)) == 0:
                  print("{}: Job {} not started yet from {}".format(time.ctime(), job_name, queue_id))

            # poll job status waiting for a result
            #
            job_url = 'http://{}@{}/job/{}/{}/api/json'.format(auth_token, jenkins_uri, job_name, job_id)
            start_epoch = int(time.time())
            while True:
              print("{}: Job started".format(time.ctime()))
              j = requests.get(job_url)
              jje = j.json()
              result = jje['result']
              if result == 'SUCCESS':
                  # Do success steps
                  print("{}: Job: {} Status: {}".format(time.ctime(), job_name, result))
                  break
              elif result == 'FAILURE':
                  # Do failure steps
                  print("{}: Job: {} Status: {}".format(time.ctime(), job_name, result))
                  sys.exit(1)
                  break
              elif result == 'ABORTED':
                  # Do aborted steps
                  print("{}: Job: {} Status: {}".format(time.ctime(), job_name, result))
                  sys.exit(1)
                  break
              else:
                  print("{}: Job: {} Status: {}. Polling again in {} secs".format(
                          time.ctime(), job_name, result, JOB_POLL_INTERVAL))

              cur_epoch = int(time.time())
              if (cur_epoch - start_epoch) > OVERALL_TIMEOUT:
                  print("{}: No status before timeout of {} secs".format(OVERALL_TIMEOUT))
                  sys.exit(1)

              time.sleep(JOB_POLL_INTERVAL)

          shell: /usr/bin/python3
      - openvpn/disconnect
      - slack/notify:
          event: fail
          template: basic_fail_1
          channel: "phoenix-circleci-notifications"

  deploy-apollo:
    environment:
      AWS_REGION: us-east-1
    docker:
      - image: cimg/base:2020.01
    steps:
      - checkout
      - run:
          name: install utilities
          command: sudo apt-get update -y && sudo apt-get install awscli -y && sudo apt-get install jq -y
      - setup_remote_docker:
          version: 18.09.3
      - run:
          name: create phoenix profile for aws cli
          command: printf "%s\n%s\n"${AWS_REGION}"\njson" "$AWS_ACCESS_KEY_ID" "$AWS_SECRET_ACCESS_KEY" | aws configure --profile phoenix
      - run:
          name: set deployment environment
          command: |
            if [ $CIRCLE_BRANCH = "master" ]; then
              echo 'export ENV=prod' >> $BASH_ENV
            elif [ $CIRCLE_BRANCH = "qa" ]; then
              echo 'export ENV=qa' >> $BASH_ENV
            elif [[ "$CIRCLE_BRANCH" == "release"* ]]; then
              echo 'export ENV=staging' >> $BASH_ENV
            fi
      - run:
          name: build and deploy apollo
          command: cd apollo && ./build-and-deploy.sh $ENV
      - run: 
          name: auto-restore db
          command: |
            if [[ "$CIRCLE_BRANCH" == "release"* ]]; then
              aws lambda invoke \
                  --function-name staging-backups-auto-restore-lambda \
                  --log-type Tail \
                  --invocation-type RequestResponse \
                  --payload '{ "connection_string": "'"${STAGING_MONGOOSE_URI}"'","database_name":"'"${STAGING_MONGODB_NAME}"'","db_webserver_password":"'"${BACKUP_SERVER_PASS}"'","db_webserver_user":"'"${BACKUP_SERVER_USER}"'"}' \
                  outputfile.txt
              LAMBDA_STATUS_CODE=$(<outputfile.txt)
              if [ "${LAMBDA_STATUS_CODE}" -eq 1 ]; then  
                 exit 1
              fi
            fi
      - slack/notify:
          event: fail
          template: basic_fail_1
          channel: "phoenix-circleci-notifications"
  build-chrome-extension:
    docker:
      - image: cimg/node:15.14.0
    steps:
      - checkout
      - run:
          name: install python
          command: sudo apt-get update -y && sudo apt-get install -y python
      - run:
          name: set deployment environment
          command: |
            if [ $CIRCLE_BRANCH = "master" ]; then
              echo 'export ENV=prod' >> $BASH_ENV
            elif [ $CIRCLE_BRANCH = "qa" ]; then
              echo 'export ENV=qa' >> $BASH_ENV
            elif [[ "$CIRCLE_BRANCH" == "release"* ]]; then
              echo 'export ENV=staging' >> $BASH_ENV
            fi
      - run:
          name: build chrome extension
          command: cd themis && ./build.sh $ENV
      - run:
          name: install utilities
          command: sudo apt-get update -y && sudo apt-get install awscli
      - run:
          name: create phoenix profile for aws cli
          command: printf "%s\n%s\n"${AWS_REGION}"\njson" "$AWS_ACCESS_KEY_ID" "$AWS_SECRET_ACCESS_KEY" | aws configure --profile phoenix
      - run:
          name: push the extension file to s3
          command: filename=$(ls themis | grep Sema_Code_Review_Assistant_ | head -1) && aws s3 cp themis/$filename s3://$ENV-chrome-store/$filename --profile phoenix
      - slack/notify:
          event: fail
          template: basic_fail_1
          channel: "phoenix-circleci-notifications"      
  phoenix-notify:
    docker:
        - image: cimg/base:2020.01
    steps: 
      - checkout
      - slack/notify:
          event: pass
          template: basic_success_1
workflows:
  version: 2
  primary:
    jobs:
      - deploy-web:
          filters:
            branches:
              only:
                - qa
                - master
                - /release-.*/
      - deploy-apollo:
          filters:
            branches:
              only:
                - qa
                - master
                - /release-.*/
      - build-chrome-extension:
          filters:
            branches:
              only:
                - qa
                - master
                - /release-.*/
      - test-web:
          filters:
            branches:
              only:
                - /release-.*/
                - DVPS-125
      - phoenix-notify:
          context: 
           - slack-secrets
          filters:
            branches:
              only:
                - qa
                - master
                - /release-.*/
          requires:
            - build-chrome-extension
            - deploy-web
            - deploy-apollo
