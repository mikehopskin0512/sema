{"info":{"type":"runner","start":"2022-02-10T15:38:23.904Z","_duration":3080,"cid":"0-2","capabilities":{"browserName":"Chrome","browserVersion":"97.0.4692.99","platformName":"win32","platformVersion":"10.0.19041","goog:chromeOptions":{"debuggerAddress":"localhost:60983"},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd"},"sanitizedCapabilities":"chrome.97_0_4692_99.win32","config":{"capabilities":{"browserName":"chrome"},"logLevel":"trace","outputDir":"C:\\SemaSoftware\\phoenix\\web\\e2e-tests\\logs","connectionRetryCount":3,"requestedCapabilities":{"browserName":"chrome"},"specs":["./src/features/**/*.feature"],"exclude":[],"suites":{},"baseUrl":"https://app.semasoftware.com/dashboard","bail":0,"waitforInterval":500,"waitforTimeout":100000,"framework":"cucumber","reporters":["spec",["html-nice",{"outputDir":"./reports/html-reports/","filename":"report.html","reportTitle":"Test Report Title","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":[],"execArgv":[],"maxInstances":1,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[null],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"logLevels":{},"connectionRetryTimeout":90000,"automationProtocol":"devtools"},"specs":["C:\\SemaSoftware\\phoenix\\web\\e2e-tests\\src\\features\\smoke_test\\snippets.feature"],"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","isMultiremote":false,"instanceOptions":{"4ead6943-609d-4a80-825c-6dbc0f54fafd":{"capabilities":{"browserName":"chrome"},"logLevel":"trace","outputDir":"C:\\SemaSoftware\\phoenix\\web\\e2e-tests\\logs","connectionRetryCount":3,"requestedCapabilities":{"browserName":"chrome"},"specs":["./src/features/**/*.feature"],"exclude":[],"suites":{},"baseUrl":"https://app.semasoftware.com/dashboard","bail":0,"waitforInterval":500,"waitforTimeout":100000,"framework":"cucumber","reporters":["spec",["html-nice",{"outputDir":"./reports/html-reports/","filename":"report.html","reportTitle":"Test Report Title","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":[],"execArgv":[],"maxInstances":1,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[null],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"logLevels":{},"connectionRetryTimeout":90000,"automationProtocol":"devtools"}},"retry":0,"failures":0,"retries":0,"end":"2022-02-10T15:38:26.984Z"},"metrics":{"passed":12,"skipped":0,"failed":0,"duration":2204,"start":"2022-02-10T15:38:24.769Z","end":"2022-02-10T15:38:26.973Z"},"title":"Master Report","suites":[{"type":"feature","start":"2022-02-10T15:38:24.769Z","_duration":2203,"tests":[],"hooks":[],"suites":[{"type":"scenario","start":"2022-02-10T15:38:24.865Z","_duration":2105,"tests":[{"type":"test","start":"2022-02-10T15:38:24.869Z","_duration":30,"uid":"363","cid":"0-2","title":"Given User click on the element \"authorizeSemaSoftwareBtn\" if visible","fullTitle":"0: Given User click on the element \"authorizeSemaSoftwareBtn\" if visible","output":[{"command":"findElement","params":{"using":"xpath","value":"//button[@id='js-oauth-authorize-btn']"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//button[@id='js-oauth-authorize-btn']"},"retries":0,"result":{"value":{}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//button[@id='js-oauth-authorize-btn']"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//button[@id='js-oauth-authorize-btn']"},"retries":0,"result":{"value":{}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:24.899Z"},{"type":"test","start":"2022-02-10T15:38:24.899Z","_duration":19,"uid":"364","cid":"0-2","title":"When I wait on element \"userLogo\" for 10000ms","fullTitle":"0: When I wait on element \"userLogo\" for 10000ms","output":[{"command":"findElement","params":{"using":"css selector","value":".navbar-menu>.navbar-end>*>a"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"css selector","value":".navbar-menu>.navbar-end>*>a"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-6"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElements","params":{"using":"css selector","value":".navbar-menu>.navbar-end>*>a"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"css selector","value":".navbar-menu>.navbar-end>*>a"},"retries":0,"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-7"}]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:24.918Z"},{"type":"test","start":"2022-02-10T15:38:24.918Z","_duration":75,"uid":"365","cid":"0-2","title":"When I click on the element \"snippetsTab\"","fullTitle":"0: When I click on the element \"snippetsTab\"","output":[{"command":"findElements","params":{"using":"css selector","value":".navbar-menu a[href='/snippets'].has-text-black-950"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"css selector","value":".navbar-menu a[href='/snippets'].has-text-black-950"},"retries":0,"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-8"}]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"css selector","value":".navbar-menu a[href='/snippets'].has-text-black-950"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"css selector","value":".navbar-menu a[href='/snippets'].has-text-black-950"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-9"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"elementClick","params":{"elementId":"ELEMENT-9"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"elementClick","params":{"elementId":"ELEMENT-9"},"retries":0,"result":{"value":null},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:24.993Z"},{"type":"test","start":"2022-02-10T15:38:24.994Z","_duration":1652,"uid":"366","cid":"0-2","title":"Then I expect that element \"collectionArea\" becomes displayed","fullTitle":"0: Then I expect that element \"collectionArea\" becomes displayed","output":[{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"result":{"value":{}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"result":{"value":{}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"result":{"value":{}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"result":{"value":{}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-10"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"executeScript","params":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-10","ELEMENT":"ELEMENT-10"}]},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"executeScript","params":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-10","ELEMENT":"ELEMENT-10"}]},"retries":0,"result":{"value":true},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.646Z"},{"type":"test","start":"2022-02-10T15:38:26.647Z","_duration":62,"uid":"367","cid":"0-2","title":"When I click on the element \"firstInActiveCollectionToggle\"","fullTitle":"0: When I click on the element \"firstInActiveCollectionToggle\"","output":[{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]"},"retries":0,"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-11"}]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-12"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"elementClick","params":{"elementId":"ELEMENT-12"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"elementClick","params":{"elementId":"ELEMENT-12"},"retries":0,"result":{"value":null},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.709Z"},{"type":"test","start":"2022-02-10T15:38:26.710Z","_duration":26,"uid":"368","cid":"0-2","title":"Then I expect that element \"firstInActiveCollectionName\" becomes displayed","fullTitle":"0: Then I expect that element \"firstInActiveCollectionName\" becomes displayed","output":[{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]/../..//p[contains(@class,'pr-10')]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]/../..//p[contains(@class,'pr-10')]"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-13"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"executeScript","params":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-13","ELEMENT":"ELEMENT-13"}]},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"executeScript","params":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-13","ELEMENT":"ELEMENT-13"}]},"retries":0,"result":{"value":true},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.736Z"},{"type":"test","start":"2022-02-10T15:38:26.736Z","_duration":34,"uid":"369","cid":"0-2","title":"When I save the name of collection \"firstInActiveCollectionName\"","fullTitle":"0: When I save the name of collection \"firstInActiveCollectionName\"","output":[{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]/../..//p[contains(@class,'pr-10')]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]/../..//p[contains(@class,'pr-10')]"},"retries":0,"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-14"}]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]/../..//p[contains(@class,'pr-10')]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]/../..//p[contains(@class,'pr-10')]"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-15"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"getElementText","params":{"elementId":"ELEMENT-15"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"getElementText","params":{"elementId":"ELEMENT-15"},"retries":0,"result":{"value":"09022022 test"},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.770Z"},{"type":"test","start":"2022-02-10T15:38:26.770Z","_duration":82,"uid":"370","cid":"0-2","title":"And I click on the element \"firstInActiveCollectionToggle\"","fullTitle":"0: And I click on the element \"firstInActiveCollectionToggle\"","output":[{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]"},"retries":0,"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-16"}]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-17"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"elementClick","params":{"elementId":"ELEMENT-17"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"elementClick","params":{"elementId":"ELEMENT-17"},"retries":0,"result":{"value":null},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.852Z"},{"type":"test","start":"2022-02-10T15:38:26.852Z","_duration":10,"uid":"371","cid":"0-2","title":"Then I expect that selected collection element \"activeCollectionsNames\" is enabled","fullTitle":"0: Then I expect that selected collection element \"activeCollectionsNames\" is enabled","output":[{"command":"findElements","params":{"using":"css selector","value":"activeCollectionsNames"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"css selector","value":"activeCollectionsNames"},"retries":0,"result":{"value":[]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.862Z"},{"type":"test","start":"2022-02-10T15:38:26.862Z","_duration":20,"uid":"372","cid":"0-2","title":"When I save the name of collection \"firstActiveCollectionName\"","fullTitle":"0: When I save the name of collection \"firstActiveCollectionName\"","output":[{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[@checked]/../..//p[contains(@class,'pr-10')]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[@checked]/../..//p[contains(@class,'pr-10')]"},"retries":0,"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-18"}]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[@checked]/../..//p[contains(@class,'pr-10')]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[@checked]/../..//p[contains(@class,'pr-10')]"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-19"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"getElementText","params":{"elementId":"ELEMENT-19"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"getElementText","params":{"elementId":"ELEMENT-19"},"retries":0,"result":{"value":"My Snippets"},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.882Z"},{"type":"test","start":"2022-02-10T15:38:26.883Z","_duration":71,"uid":"373","cid":"0-2","title":"And I click on the element \"firstActiveCollectionToggle\"","fullTitle":"0: And I click on the element \"firstActiveCollectionToggle\"","output":[{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[@checked]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[@checked]"},"retries":0,"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-20"}]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[@checked]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[@checked]"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-21"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"elementClick","params":{"elementId":"ELEMENT-21"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"elementClick","params":{"elementId":"ELEMENT-21"},"retries":0,"result":{"value":null},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.954Z"},{"type":"test","start":"2022-02-10T15:38:26.954Z","_duration":15,"uid":"374","cid":"0-2","title":"Then I expect that selected collection element \"inactiveCollectionsNames\" is enabled","fullTitle":"0: Then I expect that selected collection element \"inactiveCollectionsNames\" is enabled","output":[{"command":"findElements","params":{"using":"css selector","value":"inactiveCollectionsNames"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"css selector","value":"inactiveCollectionsNames"},"retries":0,"result":{"value":[]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"deleteSession","params":{},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"deleteSession","params":{},"retries":0,"result":{"value":null},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.969Z"}],"hooks":[{"type":"hook","start":"2022-02-10T15:38:24.866Z","_duration":2,"uid":"762","cid":"0-2","title":"","parent":"0","errors":[],"end":"2022-02-10T15:38:24.868Z"},{"type":"hook","start":"2022-02-10T15:38:26.969Z","_duration":0,"uid":"775","cid":"0-2","title":"","parent":"0","errors":[],"end":"2022-02-10T15:38:26.969Z"}],"suites":[],"hooksAndTests":[{"type":"hook","start":"2022-02-10T15:38:24.866Z","_duration":2,"uid":"762","cid":"0-2","title":"","parent":"0","errors":[],"end":"2022-02-10T15:38:24.868Z"},{"type":"test","start":"2022-02-10T15:38:24.869Z","_duration":30,"uid":"363","cid":"0-2","title":"Given User click on the element \"authorizeSemaSoftwareBtn\" if visible","fullTitle":"0: Given User click on the element \"authorizeSemaSoftwareBtn\" if visible","output":[{"command":"findElement","params":{"using":"xpath","value":"//button[@id='js-oauth-authorize-btn']"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//button[@id='js-oauth-authorize-btn']"},"retries":0,"result":{"value":{}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//button[@id='js-oauth-authorize-btn']"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//button[@id='js-oauth-authorize-btn']"},"retries":0,"result":{"value":{}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:24.899Z"},{"type":"test","start":"2022-02-10T15:38:24.899Z","_duration":19,"uid":"364","cid":"0-2","title":"When I wait on element \"userLogo\" for 10000ms","fullTitle":"0: When I wait on element \"userLogo\" for 10000ms","output":[{"command":"findElement","params":{"using":"css selector","value":".navbar-menu>.navbar-end>*>a"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"css selector","value":".navbar-menu>.navbar-end>*>a"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-6"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElements","params":{"using":"css selector","value":".navbar-menu>.navbar-end>*>a"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"css selector","value":".navbar-menu>.navbar-end>*>a"},"retries":0,"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-7"}]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:24.918Z"},{"type":"test","start":"2022-02-10T15:38:24.918Z","_duration":75,"uid":"365","cid":"0-2","title":"When I click on the element \"snippetsTab\"","fullTitle":"0: When I click on the element \"snippetsTab\"","output":[{"command":"findElements","params":{"using":"css selector","value":".navbar-menu a[href='/snippets'].has-text-black-950"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"css selector","value":".navbar-menu a[href='/snippets'].has-text-black-950"},"retries":0,"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-8"}]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"css selector","value":".navbar-menu a[href='/snippets'].has-text-black-950"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"css selector","value":".navbar-menu a[href='/snippets'].has-text-black-950"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-9"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"elementClick","params":{"elementId":"ELEMENT-9"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"elementClick","params":{"elementId":"ELEMENT-9"},"retries":0,"result":{"value":null},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:24.993Z"},{"type":"test","start":"2022-02-10T15:38:24.994Z","_duration":1652,"uid":"366","cid":"0-2","title":"Then I expect that element \"collectionArea\" becomes displayed","fullTitle":"0: Then I expect that element \"collectionArea\" becomes displayed","output":[{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"result":{"value":{}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"result":{"value":{}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"result":{"value":{}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"result":{"value":{}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[@id='collectionBody']"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-10"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"executeScript","params":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-10","ELEMENT":"ELEMENT-10"}]},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"executeScript","params":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-10","ELEMENT":"ELEMENT-10"}]},"retries":0,"result":{"value":true},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.646Z"},{"type":"test","start":"2022-02-10T15:38:26.647Z","_duration":62,"uid":"367","cid":"0-2","title":"When I click on the element \"firstInActiveCollectionToggle\"","fullTitle":"0: When I click on the element \"firstInActiveCollectionToggle\"","output":[{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]"},"retries":0,"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-11"}]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-12"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"elementClick","params":{"elementId":"ELEMENT-12"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"elementClick","params":{"elementId":"ELEMENT-12"},"retries":0,"result":{"value":null},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.709Z"},{"type":"test","start":"2022-02-10T15:38:26.710Z","_duration":26,"uid":"368","cid":"0-2","title":"Then I expect that element \"firstInActiveCollectionName\" becomes displayed","fullTitle":"0: Then I expect that element \"firstInActiveCollectionName\" becomes displayed","output":[{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]/../..//p[contains(@class,'pr-10')]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]/../..//p[contains(@class,'pr-10')]"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-13"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"executeScript","params":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-13","ELEMENT":"ELEMENT-13"}]},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"executeScript","params":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-13","ELEMENT":"ELEMENT-13"}]},"retries":0,"result":{"value":true},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.736Z"},{"type":"test","start":"2022-02-10T15:38:26.736Z","_duration":34,"uid":"369","cid":"0-2","title":"When I save the name of collection \"firstInActiveCollectionName\"","fullTitle":"0: When I save the name of collection \"firstInActiveCollectionName\"","output":[{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]/../..//p[contains(@class,'pr-10')]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]/../..//p[contains(@class,'pr-10')]"},"retries":0,"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-14"}]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]/../..//p[contains(@class,'pr-10')]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]/../..//p[contains(@class,'pr-10')]"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-15"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"getElementText","params":{"elementId":"ELEMENT-15"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"getElementText","params":{"elementId":"ELEMENT-15"},"retries":0,"result":{"value":"09022022 test"},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.770Z"},{"type":"test","start":"2022-02-10T15:38:26.770Z","_duration":82,"uid":"370","cid":"0-2","title":"And I click on the element \"firstInActiveCollectionToggle\"","fullTitle":"0: And I click on the element \"firstInActiveCollectionToggle\"","output":[{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]"},"retries":0,"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-16"}]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[not(@checked)]"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-17"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"elementClick","params":{"elementId":"ELEMENT-17"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"elementClick","params":{"elementId":"ELEMENT-17"},"retries":0,"result":{"value":null},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.852Z"},{"type":"test","start":"2022-02-10T15:38:26.852Z","_duration":10,"uid":"371","cid":"0-2","title":"Then I expect that selected collection element \"activeCollectionsNames\" is enabled","fullTitle":"0: Then I expect that selected collection element \"activeCollectionsNames\" is enabled","output":[{"command":"findElements","params":{"using":"css selector","value":"activeCollectionsNames"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"css selector","value":"activeCollectionsNames"},"retries":0,"result":{"value":[]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.862Z"},{"type":"test","start":"2022-02-10T15:38:26.862Z","_duration":20,"uid":"372","cid":"0-2","title":"When I save the name of collection \"firstActiveCollectionName\"","fullTitle":"0: When I save the name of collection \"firstActiveCollectionName\"","output":[{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[@checked]/../..//p[contains(@class,'pr-10')]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[@checked]/../..//p[contains(@class,'pr-10')]"},"retries":0,"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-18"}]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[@checked]/../..//p[contains(@class,'pr-10')]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[@checked]/../..//p[contains(@class,'pr-10')]"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-19"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"getElementText","params":{"elementId":"ELEMENT-19"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"getElementText","params":{"elementId":"ELEMENT-19"},"retries":0,"result":{"value":"My Snippets"},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.882Z"},{"type":"test","start":"2022-02-10T15:38:26.883Z","_duration":71,"uid":"373","cid":"0-2","title":"And I click on the element \"firstActiveCollectionToggle\"","fullTitle":"0: And I click on the element \"firstActiveCollectionToggle\"","output":[{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[@checked]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[@checked]"},"retries":0,"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-20"}]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[@checked]"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElement","params":{"using":"xpath","value":"//div[contains(@class,'is-clickable')][1]//input[@checked]"},"retries":0,"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ELEMENT-21"}},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"elementClick","params":{"elementId":"ELEMENT-21"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"elementClick","params":{"elementId":"ELEMENT-21"},"retries":0,"result":{"value":null},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.954Z"},{"type":"test","start":"2022-02-10T15:38:26.954Z","_duration":15,"uid":"374","cid":"0-2","title":"Then I expect that selected collection element \"inactiveCollectionsNames\" is enabled","fullTitle":"0: Then I expect that selected collection element \"inactiveCollectionsNames\" is enabled","output":[{"command":"findElements","params":{"using":"css selector","value":"inactiveCollectionsNames"},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"findElements","params":{"using":"css selector","value":"inactiveCollectionsNames"},"retries":0,"result":{"value":[]},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"},{"command":"deleteSession","params":{},"retries":0,"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"command"},{"command":"deleteSession","params":{},"retries":0,"result":{"value":null},"sessionId":"4ead6943-609d-4a80-825c-6dbc0f54fafd","cid":"0-2","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-02-10T15:38:26.969Z"},{"type":"hook","start":"2022-02-10T15:38:26.969Z","_duration":0,"uid":"775","cid":"0-2","title":"","parent":"0","errors":[],"end":"2022-02-10T15:38:26.969Z"}],"uid":"0","cid":"0-2","file":"C:\\SemaSoftware\\phoenix\\web\\e2e-tests\\src\\features\\smoke_test\\snippets.feature","title":"Snippets collection can be turned on and turned off","fullTitle":"snippets.feature:2:1: Snippets collection can be turned on and turned off","tags":[{"name":"@snippets","astNodeId":"362"},{"name":"@admin","astNodeId":"13"},{"name":"@C1704","astNodeId":"14"},{"name":"@snippet","astNodeId":"15"}],"parent":"snippets.feature:2:1","end":"2022-02-10T15:38:26.971Z"}],"hooksAndTests":[],"uid":"snippets.feature:2:1","cid":"0-2","file":"C:\\SemaSoftware\\phoenix\\web\\e2e-tests\\src\\features\\smoke_test\\snippets.feature","title":"User is able to interact with snippets properly","tags":[{"location":{"line":1,"column":1},"name":"@snippets","id":"362"}],"description":"","end":"2022-02-10T15:38:26.973Z"}],"reportFile":"C:\\SemaSoftware\\phoenix\\web\\e2e-tests\\reports\\html-reports\\master-report.html"}